# Contesto applicativo - gestionale-fullstack

## üéØ Profilo e Obiettivi

### Sviluppatore
- **Tipo**: Part-time/hobby developer
- **Esperienza**: Non programmatore professionale
- **Priorit√†**: Tranquillit√† e affidabilit√† over complessit√†
- **Approccio**: Basi robuste, evoluzione graduale
- **Constraint**: Tempo limitato, zero tolerance per downtime produzione
- **Obiettivo**: Peace of mind con setup enterprise-grade ma manageable

### Principi Guida
- **Semplicit√† first**: Soluzioni pi√π semplici che funzionano
- **Robustezza over features**: Affidabilit√† priorit√† assoluta
- **Gradualit√†**: Implementare incrementalmente
- **Professional grade**: Industry standard practices
- **Documentazione**: Ogni procedura documentata e testata

## Descrizione generale
Gestionale web aziendale per la gestione di clienti, fornitori, commesse, dipendenti e documenti, accessibile sia da LAN che da remoto tramite dominio pubblico e HTTPS.

## Struttura del progetto
- **backend/**: API RESTful sviluppate in Node.js/Express, con autenticazione JWT, rate limiting, audit log, MFA (in sviluppo), collegamento a database PostgreSQL.
- **frontend/**: Interfaccia utente sviluppata in Next.js/React, con gestione sessione, ruoli, permessi e manuale utente integrato.
- **docs/**: Tutta la documentazione tecnica, checklist operative, manuale utente e guide pratiche.

## Tecnologie utilizzate
- **Node.js/Express** per il backend (documentation Node.js: https://nodejs.org/api/all.html)
- **Next.js/React** per il frontend (documentation Next.js: https://nextjs.org/docs ; documentation React: https://react.dev/learn )
- **PostgreSQL** come database relazionale (documentation: https://www.postgresql.org/docs/online-resources/ )
- **Nginx** come reverse proxy e terminazione HTTPS (documentation: https://nginx.org/en/docs/ )
- **MikroTik** per firewall, NAT, DNS statico e resilienza di rete (documentation: https://help.mikrotik.com/docs/spaces/ROS/pages/328059/RouterOS )
- **Let's Encrypt** per i certificati SSL
- **Git** per il versionamento del codice e della documentazione

## Obiettivi
- Sicurezza, resilienza e accessibilit√† sia da LAN che da WAN
- Documentazione sempre aggiornata e checklist operative integrate nel ciclo di sviluppo
- Facilit√† di manutenzione e collaborazione

---

# Regole di Progetto - gestionale-fullstack

## üèóÔ∏è Architettura Foundation

### Setup Definitivo
PC-MAURI (10.10.10.33) - Controller
‚îú‚îÄ‚îÄ Cursor AI Remote SSH
‚îî‚îÄ‚îÄ pc-mauri-vaio (10.10.10.15) - SVILUPPO NATIVO
    ‚îî‚îÄ‚îÄ Deploy ‚Üí gestionale-server (10.10.10.16) - PRODUZIONE DOCKER

### Stack Tecnologico
**Sviluppo (pc-mauri-vaio)**
- **TUTTO LOCALE**: `npm run dev`, PostgreSQL nativo
- **Motivo**: Massima velocit√†, hot reload istantaneo
- **Workflow**: Modifiche immediate, zero overhead Docker

**Produzione (gestionale-server)**
- **TUTTO CONTAINERIZZATO**: Docker Compose
- **Motivo**: Isolamento, backup automatici, deploy atomico
- **Componenti**: App container, DB container, Nginx container

### Strategia Ibrida
- **Sviluppo**: Locale per velocit√†
- **Produzione**: Container per stabilit√†
- **Deploy**: Automatico da sviluppo a produzione

## 1. Documentazione e checklist

- Tutta la documentazione del progetto si trova nella cartella `/docs`.
- In `/docs` sono presenti:
  - **Checklist specifiche** (es. sicurezza, backup, deploy, ecc.) da seguire e aggiornare per ogni modifica o rilascio.
  - **Documentazione generale** sulla struttura del progetto, le tecnologie utilizzate, le implementazioni e gli strumenti adottati.
  - **Manuale utente**: guida pratica per l'utilizzo del gestionale, da mantenere aggiornata ad ogni nuova funzionalit√† o modifica rilevante.
  - Il materiale di sviluppo deve essere inserito nella cartella  `/docs/SVILUPPO/`
  - Le guide e i manuali devono essere inseriti nella cartella  `/docs/MANUALE/`

### 1.1. Gestione dei file di documentazione

- **Evitare la proliferazione di documenti**: lavorare sui file esistenti quando possibile, creare nuovi file solo se l'argomento √® completamente diverso e necessita di un documento dedicato.
- **Mantenere la struttura pulita**: evitare di creare confusione con troppi file, concentrarsi sui file principali e creare nuovi file solo quando strettamente necessario secondo le best practice del progetto.
- **Consolidare informazioni correlate**: quando possibile, aggiungere nuove informazioni ai documenti esistenti piuttosto che creare file separati per argomenti simili o correlati.

## 2. Regola generale per i commit

- **Prima di ogni commit**:
  - Aggiorna la checklist e la documentazione relativa nella cartella `/docs`.
  - Assicurati che tutte le modifiche, le osservazioni e le decisioni tecniche siano riportate nei file appropriati.
  - Se hai risolto un punto di una checklist, spuntalo e aggiungi eventuali note operative.
- **Dopo ogni commit**:
  - Esegui sempre il push delle modifiche documentali insieme al codice.

## 3. Gestione delle checklist

- Le checklist sono strumenti operativi fondamentali: vanno seguite, aggiornate e mantenute come parte integrante del ciclo di sviluppo.
- Ogni checklist deve essere chiara, aggiornata e facilmente consultabile.
- In caso di nuove procedure (es. sicurezza, backup, deploy, recovery, ecc.), crea una nuova checklist dedicata in `/docs`.

## 4. Manuale utente

- Il manuale utente deve essere aggiornato ogni volta che viene aggiunta o modificata una funzionalit√† rilevante.
- Il manuale deve essere scritto in modo chiaro, accessibile anche a chi non √® esperto di informatica.

## 5. Regola di resilienza e sicurezza

- Tutte le configurazioni critiche (DNS, firewall, backup, ecc.) devono essere documentate e verificate tramite checklist.
- In caso di modifiche infrastrutturali, aggiorna subito la documentazione e segnala eventuali azioni da completare.

## 6. Collaborazione

- Chiunque lavori sul progetto deve leggere e rispettare queste regole.
- Ogni modifica importante deve essere documentata e discussa, se necessario, tramite note operative o commenti nei file di documentazione.

## 7. Regola sui commit documentali

- Per modifiche puramente documentali (es. correzioni di refusi, formattazione, aggiornamento di esempi non sostanziali), valuta se √® davvero necessario fare un commit.
- Evita commit inutili e preferisci commit solo per modifiche sostanziali o che impattano la sicurezza, la procedura o la struttura.

## 8. Best practice: commit e push solo di versioni funzionanti

- Prima di ogni commit e push, √® obbligatorio testare manualmente che la versione sia funzionante e stabile (almeno nelle funzionalit√† principali).
- Non committare n√© pushare versioni che presentano errori bloccanti, bug critici o che non permettono l'uso normale dell'applicazione.
- Solo dopo aver verificato il corretto funzionamento, procedere con commit e push.

## 9. Formattazione uniforme dei nomi dei file

- **Nomi file sempre in minuscolo**: utilizzare esclusivamente lettere minuscole per i nomi dei file.
- **Separatori con trattini**: utilizzare trattini (`-`) per separare le parole nei nomi dei file.
- **Nessuna maiuscola**: evitare completamente l'uso di maiuscole nei nomi dei file.
- **Esempi corretti**:
  - ‚úÖ `automazione.md`
  - ‚úÖ `checklist-automazione.md`
  - ‚úÖ `guida-backup-e-ripristino.md`
  - ‚ùå `AUTOMAZIONE.md`
  - ‚ùå `CHECKLIST-AUTOMAZIONE.md`
  - ‚ùå `GuidaBackup.md`
- **Applicazione retroattiva**: quando si incontrano file con nomi non conformi, rinominarli seguendo questa convenzione.
- **Consistenza**: mantenere questa convenzione per tutti i file del progetto, inclusi script, configurazioni e documentazione.

## 10. Regola tassativa: sintassi Docker corretta

- **SEMPRE usare `docker compose` (senza trattino)**: la sintassi `docker-compose` √® DEPRECATA e non deve essere utilizzata.
- **Sintassi corretta**:
  - ‚úÖ `docker compose up -d`
  - ‚úÖ `docker compose down`
  - ‚úÖ `docker compose ps`
  - ‚úÖ `docker compose logs`
  - ‚ùå `docker-compose up -d` (DEPRECATO)
  - ‚ùå `docker-compose down` (DEPRECATO)
  - ‚ùå `docker-compose ps` (DEPRECATO)
- **Controllo obbligatorio**: prima di ogni commit, verificare che tutti i file (script, documentazione, configurazioni) usino la sintassi corretta.
- **Aggiornamento retroattivo**: tutti i file esistenti che usano la sintassi deprecata devono essere aggiornati immediatamente.
- **Documentazione**: tutti i comandi Docker nella documentazione devono usare la sintassi corretta.
- **Script**: tutti gli script bash, shell e di automazione devono usare la sintassi corretta.

## 11. Componenti riutilizzabili

- **Priorit√† ai componenti riutilizzabili**: dove possibile, creare componenti che possono essere riutilizzati in diverse parti dell'applicazione.
- **Principi di design**:
  - **Composizione**: preferire componenti piccoli e specializzati che possono essere combinati
  - **Props configurabili**: rendere i componenti flessibili tramite props per adattarli a diversi contesti
  - **Separazione delle responsabilit√†**: ogni componente deve avere una responsabilit√† specifica e ben definita
  - **Principio DRY (Don't Repeat Yourself)**: evitare duplicazione di codice tra componenti simili
- **Vantaggi**:
  - Riduzione della duplicazione del codice
  - Facilit√† di manutenzione e aggiornamenti
  - Consistenza nell'interfaccia utente
  - Migliore testabilit√† dei componenti
  - Riduzione del tempo di sviluppo per nuove funzionalit√†
- **Componenti UI di base obbligatori**:
  - ‚úÖ **Button**: con varianti (primary, secondary, danger, success, ghost, outline) e stati (loading, disabled)
  - ‚úÖ **Input**: con supporto per label, error, helper, icone (left/right)
  - ‚úÖ **Modal/Dialog**: componente modale riutilizzabile per form e contenuti
  - ‚úÖ **Table/DataTable**: componente tabella con sorting, filtering, pagination
  - ‚úÖ **Form**: sistema di form riutilizzabile con validazione
  - ‚úÖ **LoadingSpinner**: indicatore di caricamento standardizzato
  - ‚úÖ **ErrorMessage**: gestione errori uniforme
  - ‚úÖ **EmptyState**: stati vuoti per liste e contenuti
- **Layout components**:
  - ‚úÖ Header, sidebar, footer, navigation
  - ‚úÖ AppLayout, ClientLayout, ProtectedRoute
- **Utility components**:
  - ‚úÖ Loading states, error states, empty states
  - ‚úÖ Confirmation dialogs, tooltips, dropdowns
- **Componenti da evitare**:
  - ‚ùå Componenti monolitici troppo specifici (es. FormClienteCompleto di 74KB)
  - ‚ùå Componenti che duplicano logica esistente
  - ‚ùå Componenti che non possono essere riutilizzati in altri contesti
- **Best practice per la creazione**:
  - **Refactoring graduale**: suddividere componenti grandi in componenti pi√π piccoli
  - **Composizione vs ereditariet√†**: preferire la composizione di componenti piccoli
  - **Props interface**: definire sempre interfacce TypeScript per le props
  - **Default props**: fornire valori di default sensati per le props opzionali
  - **ForwardRef**: utilizzare React.forwardRef per componenti che devono esporre ref
- **Documentazione dei componenti**:
  - Ogni componente riutilizzabile deve essere documentato con esempi di utilizzo
  - Includere tutte le props disponibili con tipi TypeScript
  - Fornire esempi di codice per i casi d'uso pi√π comuni
  - Documentare eventuali limitazioni o requisiti specifici
- **Organizzazione dei file**:
  - **`/components/ui/`**: componenti UI di base riutilizzabili
  - **`/components/layout/`**: componenti di layout (header, sidebar, footer)
  - **`/components/forms/`**: componenti specifici per form riutilizzabili
  - **`/components/tables/`**: componenti per tabelle e data display
  - **`/components/modals/`**: componenti modali e dialog
- **Controllo qualit√†**:
  - Prima di ogni commit, verificare che non ci sia duplicazione di codice tra componenti
  - Assicurarsi che i componenti esistenti vengano riutilizzati invece di crearne di nuovi
  - Testare che i componenti funzionino correttamente in diversi contesti

## 12. Gestione warning e elementi deprecati/obsoleti

- **NON ignorare mai i warning del terminale**: ogni warning deve essere analizzato e risolto.
- **Attenzione agli elementi deprecati**: identificare e aggiornare immediatamente elementi deprecati o obsoleti.
- **Best practice per la gestione dei warning**:
  - **Analisi immediata**: quando appare un warning, fermarsi e analizzarlo
  - **Ricerca soluzioni**: cercare la causa del warning e le soluzioni disponibili
  - **Applicazione correzioni**: implementare le correzioni necessarie prima di procedere
  - **Test post-correzione**: verificare che la correzione non introduca nuovi problemi
  - **Documentazione**: documentare le correzioni applicate e le motivazioni
- **Esempi di warning da non ignorare**:
  - ‚úÖ Warning di sintassi deprecata (es. `docker-compose` vs `docker compose`)
  - ‚úÖ Warning di configurazione obsoleta (es. `version` in docker-compose.yml)
  - ‚úÖ Warning di sicurezza (es. vulnerabilit√† note)
  - ‚úÖ Warning di performance (es. buildx non installato)
- **Procedura standard per i warning**:
  1. **Identificare** il tipo di warning
  2. **Ricercare** la causa e le soluzioni
  3. **Applicare** la correzione pi√π appropriata
  4. **Testare** che tutto funzioni correttamente
  5. **Documentare** la correzione applicata
- **Controllo obbligatorio**: prima di ogni commit, verificare che non ci siano warning attivi nel sistema.

## 13. Gestione documentazione e file .md

- **Limitare la generazione di file .md superflui**: prima di creare un nuovo file .md, verificare se esiste gi√† documentazione sull'argomento.
- **Priorit√† alla documentazione esistente**: cercare di utilizzare e aggiornare i file .md gi√† presenti piuttosto che crearne di nuovi.
- **Unificazione per logica e argomenti**: raggruppare informazioni correlate negli stessi file, evitando frammentazione.
- **Eliminazione risultati non critici**: i risultati di test e analisi possono essere eliminati se non critici per il funzionamento o la sicurezza.
- **Best practice per la documentazione**:
  - **Ricerca prima di creare**: controllare sempre se esiste gi√† documentazione sull'argomento
  - **Aggiornamento vs creazione**: preferire l'aggiornamento di file esistenti
  - **Raggruppamento logico**: mantenere informazioni correlate nello stesso file
  - **Eliminazione selettiva**: rimuovere solo risultati non critici, mantenendo informazioni importanti
  - **Struttura pulita**: evitare proliferazione di file con contenuti simili
- **Criteri per eliminazione**:
  - ‚úÖ Risultati di test temporanei non critici
  - ‚úÖ Analisi preliminari superate da versioni definitive
  - ‚úÖ Log di debug non essenziali
  - ‚ùå Informazioni di sicurezza critiche
  - ‚ùå Configurazioni operative importanti
  - ‚ùå Procedure di backup e ripristino
  - ‚ùå Documentazione di architettura e struttura

## 14. REGOLA DI FERRO: Controllo servizi gi√† avviati

- **PRIMA DI AVVIARE UN SERVIZIO, VERIFICARE SEMPRE CHE NON SIA GI√Ä AVVIATO**: questa √® una regola di ferro che NON pu√≤ essere ignorata.
- **Controllo obbligatorio**: prima di ogni comando di avvio, eseguire sempre un controllo dello stato del servizio.
- **Comandi di controllo standard**:
  - ‚úÖ `docker compose ps` - per verificare i container Docker attivi
  - ‚úÖ `systemctl status [servizio]` - per servizi systemd
  - ‚úÖ `ps aux | grep [processo]` - per processi generici
  - ‚úÖ `netstat -tulpn | grep [porta]` - per verificare porte in uso
  - ‚úÖ `lsof -i :[porta]` - per verificare processi su porte specifiche
- **Procedura standard**:
  1. **Controllare** lo stato del servizio prima di avviarlo
  2. **Se attivo**: fermare il servizio esistente o scegliere una porta diversa
  3. **Se inattivo**: procedere con l'avvio
  4. **Verificare** che l'avvio sia avvenuto correttamente
- **Servizi critici da controllare**:
  - ‚úÖ Database PostgreSQL (porta 5432)
  - ‚úÖ Backend Node.js (porta 3000/3001)
  - ‚úÖ Frontend Next.js (porta 3000/3001)
  - ‚úÖ Nginx (porta 80/443)
  - ‚úÖ Redis (se utilizzato)
  - ‚úÖ Altri servizi Docker
- **Conseguenze del mancato controllo**:
  - ‚ùå Conflitti di porta (Address already in use)
  - ‚ùå Duplicazione di servizi
  - ‚ùå Consumo eccessivo di risorse
  - ‚ùå Instabilit√† del sistema
  - ‚ùå Difficolt√† nel debugging
- **Best practice**:
  - **Script di controllo**: creare script che verificano automaticamente lo stato prima dell'avvio
  - **Documentazione**: annotare sempre le porte utilizzate da ogni servizio
  - **Monitoraggio**: implementare monitoraggio continuo dello stato dei servizi
  - **Logging**: mantenere log degli avvii/arresti dei servizi

## 15. CONVENZIONI API E COMUNICAZIONE FRONTEND/BACKEND

### 15.1. Struttura Risposta API Standardizzata
- **SEMPRE** restituire formato `{success: boolean, data: any, message?: string}`
- **Frontend** deve **SEMPRE** estrarre `response.data` dalle risposte API
- **NON** usare mai direttamente la risposta completa dal frontend

```typescript
// ‚úÖ CORRETTO - Backend
res.json({
  success: true,
  data: mappedClienti,
  pagination: result.pagination
});

// ‚úÖ CORRETTO - Frontend
const response = await apiFetch<{success: boolean, data: Cliente[]}>(`/clienti`);
return response.data;

// ‚ùå SBAGLIATO - Frontend
return await apiFetch<Cliente[]>(`/clienti`);
```

### 15.2. Autenticazione Obbligatoria
- **SEMPRE** usare `apiFetch` per chiamate autenticate
- **MAI** usare `fetch` diretto per endpoint protetti
- **Verificare** che il token sia presente prima delle chiamate

```typescript
// ‚úÖ CORRETTO
const response = await apiFetch<ResponseType>('/endpoint');

// ‚ùå SBAGLIATO
const response = await fetch('/endpoint');
```

### 15.3. Ordine Routes Critico
- **Route specifiche PRIMA** di route con parametri
- **Route con parametri ULTIME** nella definizione

```typescript
// ‚úÖ CORRETTO
router.get('/stats', controller.getStats);
router.get('/max-id', controller.getMaxId);
router.get('/search', controller.search);
router.get('/:id', controller.getById); // ULTIMA

// ‚ùå SBAGLIATO
router.get('/:id', controller.getById);
router.get('/stats', controller.getStats); // Non raggiungibile!
```

## 16. SISTEMA MAPPATURA CAMPI AUTOMATICA

### 16.1. Convenzioni Naming
- **Frontend**: PascalCase (es. `RagioneSocialeC`, `Telefono`, `IndirizzoC`)
- **Backend/Database**: camelCase (es. `ragioneSocialeC`, `telefono`, `indirizzoC`)
- **SEMPRE** usare le funzioni di mappatura automatica

### 16.2. Mappatura Obbligatoria
- **Frontend ‚Üí Backend**: `mapClienteFields(clienteData)`
- **Backend ‚Üí Frontend**: `mapClienteFieldsToFrontend(clienteData)`
- **NON** mappare mai manualmente i campi

```typescript
// ‚úÖ CORRETTO - Validazione dopo mappatura
const mappedData = mapClienteFields(clienteData);
if (!mappedData.ragioneSocialeC) { ... }

// ‚ùå SBAGLIATO - Validazione su campo sbagliato
if (!clienteData.RagioneSocialeC) { ... }
```

### 16.3. Estensione per Nuove Entit√†
- **Creare** mappa campi per ogni nuova entit√†
- **Implementare** funzioni di mappatura bidirezionale
- **Utilizzare** nei controller per tutte le operazioni

## 17. GESTIONE ERRORI E AUDIT LOG

### 17.1. Struttura Controller Standard
```typescript
async methodName(req: Request, res: Response) {
  try {
    // Logica business
    const data = await repository.method();
    
    // Log audit per operazioni critiche
    await createAuditLog({
      userId: authUser?.id,
      action: 'ACTION_NAME',
      ip: (req.ip || 'unknown') as string, // Fallback obbligatorio
      details: `Dettagli operazione`
    });
    
    // Risposta successo standardizzata
    res.json({
      success: true,
      data: data
    });
  } catch (error) {
    console.error('‚ùå Errore specifico:', error);
    res.status(500).json({
      success: false,
      message: 'Messaggio utente-friendly',
      error: process.env.NODE_ENV === 'development' ? error : undefined
    });
  }
}
```

### 17.2. Audit Log Obbligatorio
- **SEMPRE** loggare operazioni critiche (CREATE, UPDATE, DELETE)
- **Includere** userId, action, ip, details
- **Non bloccare** l'applicazione se l'audit fallisce
- **Fallback** per IP mancante: `(req.ip || 'unknown')`

### 17.3. Gestione Errori Frontend
- **Gestire** sempre gli errori con try/catch
- **Implementare** stati di loading e error
- **Reindirizzare** al login per token scaduti

## 18. CONVENZIONI NOMENCLATURA FILE

### 18.1. File Markdown (.md)
- **Kebab-Case** per file normali: `guida-backup.md`, `checklist-operativa.md`
- **UPPERCASE** solo per file speciali: `README.md`, `LICENSE.md`
- **NON** usare PascalCase per file markdown

### 18.2. Script e Configurazioni
- **Snake_Case** per script .sh: `backup_database.sh`, `setup_secrets.sh`
- **Kebab-Case** per configurazioni: `nginx_gestionale.conf`

### 18.3. Cartelle
- **Kebab-Case** per cartelle principali: `docs/`, `server/`
- **Snake_Case** per sottocartelle tecniche: `docs/server/scripts/`

## 19. AMBIENTI DI SVILUPPO E PRODUZIONE

### 19.1. Ambiente Sviluppo (pc-mauri-vaio)
- **TUTTO LOCALE**: `npm run dev`, PostgreSQL nativo
- **Motivo**: Massima velocit√†, hot reload istantaneo
- **Workflow**: Modifiche immediate, zero overhead Docker

### 19.2. Ambiente Produzione (gestionale-server)
- **TUTTO CONTAINERIZZATO**: Docker Compose
- **Motivo**: Isolamento, backup automatici, deploy atomico
- **Componenti**: App container, DB container, Nginx container

### 19.3. Strategia Ibrida
- **Sviluppo**: Locale per velocit√†
- **Produzione**: Container per stabilit√†
- **Deploy**: Automatico da sviluppo a produzione

## 20. SICUREZZA E BACKUP

### 20.1. Gestione Credenziali
- **SEMPRE** usare file separati per password
- **NON** committare mai credenziali nel codice
- **Utilizzare** variabili d'ambiente per configurazioni sensibili

### 20.2. Backup Automatici
- **NAS Synology**: Backup principale
- **Locale**: Backup di emergenza
- **Verificare** regolarmente i log di backup

### 20.3. Monitoraggio
- **Dependabot**: Monitoraggio vulnerabilit√† automatico
- **Script automatici**: Controllo server, database, SSL
- **Alert**: Notifiche per problemi critici

## 21. üõ°Ô∏è STRATEGIA BACKUP PER AMBIENTE IBRIDO

### **PRINCIPIO FONDAMENTALE: SEPARAZIONE DELLE RESPONSABILIT√Ä**

**Ambiente Sviluppo (pc-mauri-vaio) - SOLO BACKUP SVILUPPO**
```
‚úÖ DOVREBBE CONTENERE:
- Backup database sviluppo (locale)
- Backup configurazioni sviluppo
- Backup codice sorgente (Git)
- Log di sviluppo

‚ùå NON DOVREBBE CONTENERE:
- Backup database produzione
- Backup configurazioni produzione
- Dati sensibili produzione
```

**Ambiente Produzione (gestionale-server) - SOLO BACKUP PRODUZIONE**
```
‚úÖ DOVREBBE CONTENERE:
- Backup database produzione
- Backup configurazioni produzione
- Backup segreti produzione
- Log di produzione

‚ùå NON DOVREBBE CONTENERE:
- Backup sviluppo
- Codice sorgente (solo runtime)
```

**NAS Synology (10.10.10.21) - BACKUP CENTRALIZZATO**
```
‚úÖ CONTIENE:
- Copia di sicurezza produzione
- Copia di sicurezza sviluppo (opzionale)
- Versioning e deduplicazione
- Cifratura GPG per sicurezza
```

### **Vantaggi di Questa Strategia**
- ‚úÖ **Sicurezza**: Dati sensibili separati
- ‚úÖ **Performance**: Backup veloci e locali
- ‚úÖ **Manutenibilit√†**: Responsabilit√† chiare
- ‚úÖ **Scalabilit√†**: Ogni ambiente gestisce i suoi dati

## 22. üîÑ WORKFLOW ROBUSTO

### Sviluppo Quotidiano
```bash
# Su pc-mauri-vaio via Cursor SSH
cd gestionale-fullstack
npm run dev                    # Sviluppo con hot reload
npx prisma studio             # GUI database quando serve
git add . && git commit -m "..." # Version control

# Database changes
npx prisma migrate dev --name "feature-name"  # Auto-migration
```

### Deploy Produzione (SICURO)
```bash
# 1. Push codice
git push origin main

# 2. Deploy su gestionale-server
ssh gestionale-server
cd /opt/gestionale-fullstack
git pull origin main

# 3. Deploy con migrations automatiche
docker compose build app --no-cache
docker compose up -d

# 4. Verifica deployment
docker compose logs -f app
curl http://localhost/api/health  # Se hai endpoint health
```

## 23. üéì COMPETENZE MINIME RICHIESTE

### Docker Basics
```bash
docker compose up -d          # Start services
docker compose down           # Stop services  
docker compose logs app       # View logs
docker compose build --no-cache # Rebuild containers
```

### PostgreSQL Basics
```bash
pg_dump -U postgres gestionale > backup.sql    # Backup
psql -U postgres -d gestionale < backup.sql    # Restore
docker exec -it postgres psql -U postgres      # Connect
```

### Prisma Essentials
```bash
npx prisma migrate dev        # Create migration
npx prisma migrate deploy     # Apply migrations
npx prisma studio            # GUI database
npx prisma generate          # Generate client
```

### Linux Basics
```bash
ssh user@server              # Remote access
scp file user@server:/path   # Copy files
crontab -e                   # Schedule tasks
systemctl status service     # Check service status
```

## 24. üí° GUIDELINES PER AI ASSISTANT

### Principi Guida
- **Semplicit√† first**: Sempre preferire soluzione pi√π semplice che funzioni
- **Robustezza over features**: Affidabilit√† priorit√† assoluta
- **Documentazione**: Ogni procedura deve essere documentata
- **Testing**: Ogni script/procedura deve essere testata
- **Gradualit√†**: Implementare features incrementalmente

### Quando Suggerire Cosa
- **Problemi semplici**: Soluzioni native/dirette
- **Problemi complessi**: Docker-based solutions
- **Sicurezza**: Mai compromessi, sempre best practices
- **Performance**: Bilanciare con semplicit√† di maintenance
- **Scaling**: Solo quando realmente necessario

### Red Flags da Evitare
- ‚ùå Over-engineering per problemi semplici
- ‚ùå Soluzioni che richiedono maintenance continua
- ‚ùå Single points of failure senza backup
- ‚ùå Configurazioni senza rollback plan
- ‚ùå Security shortcuts per semplicit√†

---

**Queste regole sono parte integrante del progetto e vanno rispettate per garantire qualit√†, sicurezza e continuit√† operativa.**