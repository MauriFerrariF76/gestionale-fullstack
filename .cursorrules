# Contesto applicativo - gestionale-fullstack

## Descrizione generale
Gestionale web aziendale per la gestione di clienti, fornitori, commesse, dipendenti e documenti, accessibile sia da LAN che da remoto tramite dominio pubblico e HTTPS.

## Struttura del progetto
- **backend/**: API RESTful sviluppate in Node.js/Express, con autenticazione JWT, rate limiting, audit log, MFA (in sviluppo), collegamento a database PostgreSQL.
- **frontend/**: Interfaccia utente sviluppata in Next.js/React, con gestione sessione, ruoli, permessi e manuale utente integrato.
- **docs/**: Tutta la documentazione tecnica, checklist operative, manuale utente e guide pratiche.

## Tecnologie utilizzate
- **Node.js/Express** per il backend (documentation Node.js: https://nodejs.org/api/all.html)
- **Next.js/React** per il frontend (documentation Next.js: https://nextjs.org/docs ; documentation React: https://react.dev/learn )
- **PostgreSQL** come database relazionale (documentation: https://www.postgresql.org/docs/online-resources/ )
- **Nginx** come reverse proxy e terminazione HTTPS (documentation: https://nginx.org/en/docs/ )
- **MikroTik** per firewall, NAT, DNS statico e resilienza di rete (documentation: https://help.mikrotik.com/docs/spaces/ROS/pages/328059/RouterOS )
- **Let's Encrypt** per i certificati SSL
- **Git** per il versionamento del codice e della documentazione

## Obiettivi
- Sicurezza, resilienza e accessibilità sia da LAN che da WAN
- Documentazione sempre aggiornata e checklist operative integrate nel ciclo di sviluppo
- Facilità di manutenzione e collaborazione

---

# Regole di Progetto - gestionale-fullstack

## 1. Documentazione e checklist

- Tutta la documentazione del progetto si trova nella cartella `/docs`.
- In `/docs` sono presenti:
  - **Checklist specifiche** (es. sicurezza, backup, deploy, ecc.) da seguire e aggiornare per ogni modifica o rilascio.
  - **Documentazione generale** sulla struttura del progetto, le tecnologie utilizzate, le implementazioni e gli strumenti adottati.
  - **Manuale utente**: guida pratica per l'utilizzo del gestionale, da mantenere aggiornata ad ogni nuova funzionalità o modifica rilevante.
  - Il materiale di sviluppo deve essere inserito nella cartella  `/docs/SVILUPPO/`
  - Le guide e i manuali devono essere inseriti nella cartella  `/docs/MANUALE/`

### 1.1. Gestione dei file di documentazione

- **Evitare la proliferazione di documenti**: lavorare sui file esistenti quando possibile, creare nuovi file solo se l'argomento è completamente diverso e necessita di un documento dedicato.
- **Mantenere la struttura pulita**: evitare di creare confusione con troppi file, concentrarsi sui file principali e creare nuovi file solo quando strettamente necessario secondo le best practice del progetto.
- **Consolidare informazioni correlate**: quando possibile, aggiungere nuove informazioni ai documenti esistenti piuttosto che creare file separati per argomenti simili o correlati.


## 2. Regola generale per i commit

- **Prima di ogni commit**:
  - Aggiorna la checklist e la documentazione relativa nella cartella `/docs`.
  - Assicurati che tutte le modifiche, le osservazioni e le decisioni tecniche siano riportate nei file appropriati.
  - Se hai risolto un punto di una checklist, spuntalo e aggiungi eventuali note operative.
- **Dopo ogni commit**:
  - Esegui sempre il push delle modifiche documentali insieme al codice.

## 3. Gestione delle checklist

- Le checklist sono strumenti operativi fondamentali: vanno seguite, aggiornate e mantenute come parte integrante del ciclo di sviluppo.
- Ogni checklist deve essere chiara, aggiornata e facilmente consultabile.
- In caso di nuove procedure (es. sicurezza, backup, deploy, recovery, ecc.), crea una nuova checklist dedicata in `/docs`.

## 4. Manuale utente

- Il manuale utente deve essere aggiornato ogni volta che viene aggiunta o modificata una funzionalità rilevante.
- Il manuale deve essere scritto in modo chiaro, accessibile anche a chi non è esperto di informatica.

## 5. Regola di resilienza e sicurezza

- Tutte le configurazioni critiche (DNS, firewall, backup, ecc.) devono essere documentate e verificate tramite checklist.
- In caso di modifiche infrastrutturali, aggiorna subito la documentazione e segnala eventuali azioni da completare.

## 6. Collaborazione

- Chiunque lavori sul progetto deve leggere e rispettare queste regole.
- Ogni modifica importante deve essere documentata e discussa, se necessario, tramite note operative o commenti nei file di documentazione.

## 7. Regola sui commit documentali

- Per modifiche puramente documentali (es. correzioni di refusi, formattazione, aggiornamento di esempi non sostanziali), valuta se è davvero necessario fare un commit.
- Evita commit inutili e preferisci commit solo per modifiche sostanziali o che impattano la sicurezza, la procedura o la struttura.

## 8. Best practice: commit e push solo di versioni funzionanti

- Prima di ogni commit e push, è obbligatorio testare manualmente che la versione sia funzionante e stabile (almeno nelle funzionalità principali).
- Non committare né pushare versioni che presentano errori bloccanti, bug critici o che non permettono l'uso normale dell'applicazione.
- Solo dopo aver verificato il corretto funzionamento, procedere con commit e push.

## 9. Formattazione uniforme dei nomi dei file

- **Nomi file sempre in minuscolo**: utilizzare esclusivamente lettere minuscole per i nomi dei file.
- **Separatori con trattini**: utilizzare trattini (`-`) per separare le parole nei nomi dei file.
- **Nessuna maiuscola**: evitare completamente l'uso di maiuscole nei nomi dei file.
- **Esempi corretti**:
  - ✅ `automazione.md`
  - ✅ `checklist-automazione.md`
  - ✅ `guida-backup-e-ripristino.md`
  - ❌ `AUTOMAZIONE.md`
  - ❌ `CHECKLIST-AUTOMAZIONE.md`
  - ❌ `GuidaBackup.md`
- **Applicazione retroattiva**: quando si incontrano file con nomi non conformi, rinominarli seguendo questa convenzione.
- **Consistenza**: mantenere questa convenzione per tutti i file del progetto, inclusi script, configurazioni e documentazione.

## 10. Regola tassativa: sintassi Docker corretta

- **SEMPRE usare `docker compose` (senza trattino)**: la sintassi `docker-compose` è DEPRECATA e non deve essere utilizzata.
- **Sintassi corretta**:
  - ✅ `docker compose up -d`
  - ✅ `docker compose down`
  - ✅ `docker compose ps`
  - ✅ `docker compose logs`
  - ❌ `docker-compose up -d` (DEPRECATO)
  - ❌ `docker-compose down` (DEPRECATO)
  - ❌ `docker-compose ps` (DEPRECATO)
- **Controllo obbligatorio**: prima di ogni commit, verificare che tutti i file (script, documentazione, configurazioni) usino la sintassi corretta.
- **Aggiornamento retroattivo**: tutti i file esistenti che usano la sintassi deprecata devono essere aggiornati immediatamente.
- **Documentazione**: tutti i comandi Docker nella documentazione devono usare la sintassi corretta.
- **Script**: tutti gli script bash, shell e di automazione devono usare la sintassi corretta.

## 11. Componenti riutilizzabili

- **Priorità ai componenti riutilizzabili**: dove possibile, creare componenti che possono essere riutilizzati in diverse parti dell'applicazione.
- **Principi di design**:
  - **Composizione**: preferire componenti piccoli e specializzati che possono essere combinati
  - **Props configurabili**: rendere i componenti flessibili tramite props per adattarli a diversi contesti
  - **Separazione delle responsabilità**: ogni componente deve avere una responsabilità specifica e ben definita
  - **Principio DRY (Don't Repeat Yourself)**: evitare duplicazione di codice tra componenti simili
- **Vantaggi**:
  - Riduzione della duplicazione del codice
  - Facilità di manutenzione e aggiornamenti
  - Consistenza nell'interfaccia utente
  - Migliore testabilità dei componenti
  - Riduzione del tempo di sviluppo per nuove funzionalità
- **Componenti UI di base obbligatori**:
  - ✅ **Button**: con varianti (primary, secondary, danger, success, ghost, outline) e stati (loading, disabled)
  - ✅ **Input**: con supporto per label, error, helper, icone (left/right)
  - ✅ **Modal/Dialog**: componente modale riutilizzabile per form e contenuti
  - ✅ **Table/DataTable**: componente tabella con sorting, filtering, pagination
  - ✅ **Form**: sistema di form riutilizzabile con validazione
  - ✅ **LoadingSpinner**: indicatore di caricamento standardizzato
  - ✅ **ErrorMessage**: gestione errori uniforme
  - ✅ **EmptyState**: stati vuoti per liste e contenuti
- **Layout components**:
  - ✅ Header, sidebar, footer, navigation
  - ✅ AppLayout, ClientLayout, ProtectedRoute
- **Utility components**:
  - ✅ Loading states, error states, empty states
  - ✅ Confirmation dialogs, tooltips, dropdowns
- **Componenti da evitare**:
  - ❌ Componenti monolitici troppo specifici (es. FormClienteCompleto di 74KB)
  - ❌ Componenti che duplicano logica esistente
  - ❌ Componenti che non possono essere riutilizzati in altri contesti
- **Best practice per la creazione**:
  - **Refactoring graduale**: suddividere componenti grandi in componenti più piccoli
  - **Composizione vs ereditarietà**: preferire la composizione di componenti piccoli
  - **Props interface**: definire sempre interfacce TypeScript per le props
  - **Default props**: fornire valori di default sensati per le props opzionali
  - **ForwardRef**: utilizzare React.forwardRef per componenti che devono esporre ref
- **Documentazione dei componenti**:
  - Ogni componente riutilizzabile deve essere documentato con esempi di utilizzo
  - Includere tutte le props disponibili con tipi TypeScript
  - Fornire esempi di codice per i casi d'uso più comuni
  - Documentare eventuali limitazioni o requisiti specifici
- **Organizzazione dei file**:
  - **`/components/ui/`**: componenti UI di base riutilizzabili
  - **`/components/layout/`**: componenti di layout (header, sidebar, footer)
  - **`/components/forms/`**: componenti specifici per form riutilizzabili
  - **`/components/tables/`**: componenti per tabelle e data display
  - **`/components/modals/`**: componenti modali e dialog
- **Controllo qualità**:
  - Prima di ogni commit, verificare che non ci sia duplicazione di codice tra componenti
  - Assicurarsi che i componenti esistenti vengano riutilizzati invece di crearne di nuovi
  - Testare che i componenti funzionino correttamente in diversi contesti

## 12. Gestione warning e elementi deprecati/obsoleti

- **NON ignorare mai i warning del terminale**: ogni warning deve essere analizzato e risolto.
- **Attenzione agli elementi deprecati**: identificare e aggiornare immediatamente elementi deprecati o obsoleti.
- **Best practice per la gestione dei warning**:
  - **Analisi immediata**: quando appare un warning, fermarsi e analizzarlo
  - **Ricerca soluzioni**: cercare la causa del warning e le soluzioni disponibili
  - **Applicazione correzioni**: implementare le correzioni necessarie prima di procedere
  - **Test post-correzione**: verificare che la correzione non introduca nuovi problemi
  - **Documentazione**: documentare le correzioni applicate e le motivazioni
- **Esempi di warning da non ignorare**:
  - ✅ Warning di sintassi deprecata (es. `docker-compose` vs `docker compose`)
  - ✅ Warning di configurazione obsoleta (es. `version` in docker-compose.yml)
  - ✅ Warning di sicurezza (es. vulnerabilità note)
  - ✅ Warning di performance (es. buildx non installato)
- **Procedura standard per i warning**:
  1. **Identificare** il tipo di warning
  2. **Ricercare** la causa e le soluzioni
  3. **Applicare** la correzione più appropriata
  4. **Testare** che tutto funzioni correttamente
  5. **Documentare** la correzione applicata
- **Controllo obbligatorio**: prima di ogni commit, verificare che non ci siano warning attivi nel sistema.

## 13. Gestione documentazione e file .md

- **Limitare la generazione di file .md superflui**: prima di creare un nuovo file .md, verificare se esiste già documentazione sull'argomento.
- **Priorità alla documentazione esistente**: cercare di utilizzare e aggiornare i file .md già presenti piuttosto che crearne di nuovi.
- **Unificazione per logica e argomenti**: raggruppare informazioni correlate negli stessi file, evitando frammentazione.
- **Eliminazione risultati non critici**: i risultati di test e analisi possono essere eliminati se non critici per il funzionamento o la sicurezza.
- **Best practice per la documentazione**:
  - **Ricerca prima di creare**: controllare sempre se esiste già documentazione sull'argomento
  - **Aggiornamento vs creazione**: preferire l'aggiornamento di file esistenti
  - **Raggruppamento logico**: mantenere informazioni correlate nello stesso file
  - **Eliminazione selettiva**: rimuovere solo risultati non critici, mantenendo informazioni importanti
  - **Struttura pulita**: evitare proliferazione di file con contenuti simili
- **Criteri per eliminazione**:
  - ✅ Risultati di test temporanei non critici
  - ✅ Analisi preliminari superate da versioni definitive
  - ✅ Log di debug non essenziali
  - ❌ Informazioni di sicurezza critiche
  - ❌ Configurazioni operative importanti
  - ❌ Procedure di backup e ripristino
  - ❌ Documentazione di architettura e struttura

## 14. REGOLA DI FERRO: Controllo servizi già avviati

- **PRIMA DI AVVIARE UN SERVIZIO, VERIFICARE SEMPRE CHE NON SIA GIÀ AVVIATO**: questa è una regola di ferro che NON può essere ignorata.
- **Controllo obbligatorio**: prima di ogni comando di avvio, eseguire sempre un controllo dello stato del servizio.
- **Comandi di controllo standard**:
  - ✅ `docker compose ps` - per verificare i container Docker attivi
  - ✅ `systemctl status [servizio]` - per servizi systemd
  - ✅ `ps aux | grep [processo]` - per processi generici
  - ✅ `netstat -tulpn | grep [porta]` - per verificare porte in uso
  - ✅ `lsof -i :[porta]` - per verificare processi su porte specifiche
- **Procedura standard**:
  1. **Controllare** lo stato del servizio prima di avviarlo
  2. **Se attivo**: fermare il servizio esistente o scegliere una porta diversa
  3. **Se inattivo**: procedere con l'avvio
  4. **Verificare** che l'avvio sia avvenuto correttamente
- **Servizi critici da controllare**:
  - ✅ Database PostgreSQL (porta 5432)
  - ✅ Backend Node.js (porta 3000/3001)
  - ✅ Frontend Next.js (porta 3000/3001)
  - ✅ Nginx (porta 80/443)
  - ✅ Redis (se utilizzato)
  - ✅ Altri servizi Docker
- **Conseguenze del mancato controllo**:
  - ❌ Conflitti di porta (Address already in use)
  - ❌ Duplicazione di servizi
  - ❌ Consumo eccessivo di risorse
  - ❌ Instabilità del sistema
  - ❌ Difficoltà nel debugging
- **Best practice**:
  - **Script di controllo**: creare script che verificano automaticamente lo stato prima dell'avvio
  - **Documentazione**: annotare sempre le porte utilizzate da ogni servizio
  - **Monitoraggio**: implementare monitoraggio continuo dello stato dei servizi
  - **Logging**: mantenere log degli avvii/arresti dei servizi

## 15. CONVENZIONI API E COMUNICAZIONE FRONTEND/BACKEND

### 15.1. Struttura Risposta API Standardizzata
- **SEMPRE** restituire formato `{success: boolean, data: any, message?: string}`
- **Frontend** deve **SEMPRE** estrarre `response.data` dalle risposte API
- **NON** usare mai direttamente la risposta completa dal frontend

```typescript
// ✅ CORRETTO - Backend
res.json({
  success: true,
  data: mappedClienti,
  pagination: result.pagination
});

// ✅ CORRETTO - Frontend
const response = await apiFetch<{success: boolean, data: Cliente[]}>(`/clienti`);
return response.data;

// ❌ SBAGLIATO - Frontend
return await apiFetch<Cliente[]>(`/clienti`);
```

### 15.2. Autenticazione Obbligatoria
- **SEMPRE** usare `apiFetch` per chiamate autenticate
- **MAI** usare `fetch` diretto per endpoint protetti
- **Verificare** che il token sia presente prima delle chiamate

```typescript
// ✅ CORRETTO
const response = await apiFetch<ResponseType>('/endpoint');

// ❌ SBAGLIATO
const response = await fetch('/endpoint');
```

### 15.3. Ordine Routes Critico
- **Route specifiche PRIMA** di route con parametri
- **Route con parametri ULTIME** nella definizione

```typescript
// ✅ CORRETTO
router.get('/stats', controller.getStats);
router.get('/max-id', controller.getMaxId);
router.get('/search', controller.search);
router.get('/:id', controller.getById); // ULTIMA

// ❌ SBAGLIATO
router.get('/:id', controller.getById);
router.get('/stats', controller.getStats); // Non raggiungibile!
```

## 16. SISTEMA MAPPATURA CAMPI AUTOMATICA

### 16.1. Convenzioni Naming
- **Frontend**: PascalCase (es. `RagioneSocialeC`, `Telefono`, `IndirizzoC`)
- **Backend/Database**: camelCase (es. `ragioneSocialeC`, `telefono`, `indirizzoC`)
- **SEMPRE** usare le funzioni di mappatura automatica

### 16.2. Mappatura Obbligatoria
- **Frontend → Backend**: `mapClienteFields(clienteData)`
- **Backend → Frontend**: `mapClienteFieldsToFrontend(clienteData)`
- **NON** mappare mai manualmente i campi

```typescript
// ✅ CORRETTO - Validazione dopo mappatura
const mappedData = mapClienteFields(clienteData);
if (!mappedData.ragioneSocialeC) { ... }

// ❌ SBAGLIATO - Validazione su campo sbagliato
if (!clienteData.RagioneSocialeC) { ... }
```

### 16.3. Estensione per Nuove Entità
- **Creare** mappa campi per ogni nuova entità
- **Implementare** funzioni di mappatura bidirezionale
- **Utilizzare** nei controller per tutte le operazioni

## 17. GESTIONE ERRORI E AUDIT LOG

### 17.1. Struttura Controller Standard
```typescript
async methodName(req: Request, res: Response) {
  try {
    // Logica business
    const data = await repository.method();
    
    // Log audit per operazioni critiche
    await createAuditLog({
      userId: authUser?.id,
      action: 'ACTION_NAME',
      ip: (req.ip || 'unknown') as string, // Fallback obbligatorio
      details: `Dettagli operazione`
    });
    
    // Risposta successo standardizzata
    res.json({
      success: true,
      data: data
    });
  } catch (error) {
    console.error('❌ Errore specifico:', error);
    res.status(500).json({
      success: false,
      message: 'Messaggio utente-friendly',
      error: process.env.NODE_ENV === 'development' ? error : undefined
    });
  }
}
```

### 17.2. Audit Log Obbligatorio
- **SEMPRE** loggare operazioni critiche (CREATE, UPDATE, DELETE)
- **Includere** userId, action, ip, details
- **Non bloccare** l'applicazione se l'audit fallisce
- **Fallback** per IP mancante: `(req.ip || 'unknown')`

### 17.3. Gestione Errori Frontend
- **Gestire** sempre gli errori con try/catch
- **Implementare** stati di loading e error
- **Reindirizzare** al login per token scaduti

## 18. CONVENZIONI NOMENCLATURA FILE

### 18.1. File Markdown (.md)
- **Kebab-Case** per file normali: `guida-backup.md`, `checklist-operativa.md`
- **UPPERCASE** solo per file speciali: `README.md`, `LICENSE.md`
- **NON** usare PascalCase per file markdown

### 18.2. Script e Configurazioni
- **Snake_Case** per script .sh: `backup_database.sh`, `setup_secrets.sh`
- **Kebab-Case** per configurazioni: `nginx_gestionale.conf`

### 18.3. Cartelle
- **Kebab-Case** per cartelle principali: `docs/`, `server/`
- **Snake_Case** per sottocartelle tecniche: `docs/server/scripts/`

## 19. AMBIENTI DI SVILUPPO E PRODUZIONE

### 19.1. Ambiente Sviluppo (pc-mauri-vaio)
- **TUTTO LOCALE**: `npm run dev`, PostgreSQL nativo
- **Motivo**: Massima velocità, hot reload istantaneo
- **Workflow**: Modifiche immediate, zero overhead Docker

### 19.2. Ambiente Produzione (gestionale-server)
- **TUTTO CONTAINERIZZATO**: Docker Compose
- **Motivo**: Isolamento, backup automatici, deploy atomico
- **Componenti**: App container, DB container, Nginx container

### 19.3. Strategia Ibrida
- **Sviluppo**: Locale per velocità
- **Produzione**: Container per stabilità
- **Deploy**: Automatico da sviluppo a produzione

## 20. SICUREZZA E BACKUP

### 20.1. Gestione Credenziali
- **SEMPRE** usare file separati per password
- **NON** committare mai credenziali nel codice
- **Utilizzare** variabili d'ambiente per configurazioni sensibili

### 20.2. Backup Automatici
- **NAS Synology**: Backup principale
- **Locale**: Backup di emergenza
- **Verificare** regolarmente i log di backup

### 20.3. Monitoraggio
- **Dependabot**: Monitoraggio vulnerabilità automatico
- **Script automatici**: Controllo server, database, SSL
- **Alert**: Notifiche per problemi critici

---

**Queste regole sono parte integrante del progetto e vanno rispettate per garantire qualità, sicurezza e continuità operativa.**