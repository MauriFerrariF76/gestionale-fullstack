# Contesto applicativo - gestionale-fullstack

## Descrizione generale
Gestionale web aziendale per la gestione di clienti, fornitori, commesse, dipendenti e documenti, accessibile sia da LAN che da remoto tramite dominio pubblico e HTTPS.

## Struttura del progetto
- **backend/**: API RESTful sviluppate in Node.js/Express, con autenticazione JWT, rate limiting, audit log, MFA (in sviluppo), collegamento a database PostgreSQL.
- **frontend/**: Interfaccia utente sviluppata in Next.js/React, con gestione sessione, ruoli, permessi e manuale utente integrato.
- **docs/**: Tutta la documentazione tecnica, checklist operative, manuale utente e guide pratiche.

## Tecnologie utilizzate
- **Node.js/Express** per il backend (documentation Node.js: https://nodejs.org/api/all.html)
- **Next.js/React** per il frontend (documentation Next.js: https://nextjs.org/docs ; documentation React: https://react.dev/learn )
- **PostgreSQL** come database relazionale (documentation: https://www.postgresql.org/docs/online-resources/ )
- **Nginx** come reverse proxy e terminazione HTTPS (documentation: https://nginx.org/en/docs/ )
- **MikroTik** per firewall, NAT, DNS statico e resilienza di rete (documentation: https://help.mikrotik.com/docs/spaces/ROS/pages/328059/RouterOS )
- **Let's Encrypt** per i certificati SSL
- **Git** per il versionamento del codice e della documentazione

## Obiettivi
- Sicurezza, resilienza e accessibilità sia da LAN che da WAN
- Documentazione sempre aggiornata e checklist operative integrate nel ciclo di sviluppo
- Facilità di manutenzione e collaborazione

---

# Regole di Progetto - gestionale-fullstack

## 1. Documentazione e checklist

- Tutta la documentazione del progetto si trova nella cartella `/docs`.
- In `/docs` sono presenti:
  - **Checklist specifiche** (es. sicurezza, backup, deploy, ecc.) da seguire e aggiornare per ogni modifica o rilascio.
  - **Documentazione generale** sulla struttura del progetto, le tecnologie utilizzate, le implementazioni e gli strumenti adottati.
  - **Manuale utente**: guida pratica per l'utilizzo del gestionale, da mantenere aggiornata ad ogni nuova funzionalità o modifica rilevante.
  - Il materiale di sviluppo deve essere inserito nella cartella  `/docs/SVILUPPO/`
  - Le guide e i manuali devono essere inseriti nella cartella  `/docs/MANUALE/`

### 1.1. Gestione dei file di documentazione

- **Evitare la proliferazione di documenti**: lavorare sui file esistenti quando possibile, creare nuovi file solo se l'argomento è completamente diverso e necessita di un documento dedicato.
- **Mantenere la struttura pulita**: evitare di creare confusione con troppi file, concentrarsi sui file principali e creare nuovi file solo quando strettamente necessario secondo le best practice del progetto.
- **Consolidare informazioni correlate**: quando possibile, aggiungere nuove informazioni ai documenti esistenti piuttosto che creare file separati per argomenti simili o correlati.


## 2. Regola generale per i commit

- **Prima di ogni commit**:
  - Aggiorna la checklist e la documentazione relativa nella cartella `/docs`.
  - Assicurati che tutte le modifiche, le osservazioni e le decisioni tecniche siano riportate nei file appropriati.
  - Se hai risolto un punto di una checklist, spuntalo e aggiungi eventuali note operative.
- **Dopo ogni commit**:
  - Esegui sempre il push delle modifiche documentali insieme al codice.

## 3. Gestione delle checklist

- Le checklist sono strumenti operativi fondamentali: vanno seguite, aggiornate e mantenute come parte integrante del ciclo di sviluppo.
- Ogni checklist deve essere chiara, aggiornata e facilmente consultabile.
- In caso di nuove procedure (es. sicurezza, backup, deploy, recovery, ecc.), crea una nuova checklist dedicata in `/docs`.

## 4. Manuale utente

- Il manuale utente deve essere aggiornato ogni volta che viene aggiunta o modificata una funzionalità rilevante.
- Il manuale deve essere scritto in modo chiaro, accessibile anche a chi non è esperto di informatica.

## 5. Regola di resilienza e sicurezza

- Tutte le configurazioni critiche (DNS, firewall, backup, ecc.) devono essere documentate e verificate tramite checklist.
- In caso di modifiche infrastrutturali, aggiorna subito la documentazione e segnala eventuali azioni da completare.

## 6. Collaborazione

- Chiunque lavori sul progetto deve leggere e rispettare queste regole.
- Ogni modifica importante deve essere documentata e discussa, se necessario, tramite note operative o commenti nei file di documentazione.

## 7. Regola sui commit documentali

- Per modifiche puramente documentali (es. correzioni di refusi, formattazione, aggiornamento di esempi non sostanziali), valuta se è davvero necessario fare un commit.
- Evita commit inutili e preferisci commit solo per modifiche sostanziali o che impattano la sicurezza, la procedura o la struttura.

## 8. Best practice: commit e push solo di versioni funzionanti

- Prima di ogni commit e push, è obbligatorio testare manualmente che la versione sia funzionante e stabile (almeno nelle funzionalità principali).
- Non committare né pushare versioni che presentano errori bloccanti, bug critici o che non permettono l'uso normale dell'applicazione.
- Solo dopo aver verificato il corretto funzionamento, procedere con commit e push.

## 9. Formattazione uniforme dei nomi dei file

- **Nomi file sempre in minuscolo**: utilizzare esclusivamente lettere minuscole per i nomi dei file.
- **Separatori con trattini**: utilizzare trattini (`-`) per separare le parole nei nomi dei file.
- **Nessuna maiuscola**: evitare completamente l'uso di maiuscole nei nomi dei file.
- **Esempi corretti**:
  - ✅ `automazione.md`
  - ✅ `checklist-automazione.md`
  - ✅ `guida-backup-e-ripristino.md`
  - ❌ `AUTOMAZIONE.md`
  - ❌ `CHECKLIST-AUTOMAZIONE.md`
  - ❌ `GuidaBackup.md`
- **Applicazione retroattiva**: quando si incontrano file con nomi non conformi, rinominarli seguendo questa convenzione.
- **Consistenza**: mantenere questa convenzione per tutti i file del progetto, inclusi script, configurazioni e documentazione.

## 10. Regola tassativa: sintassi Docker corretta

- **SEMPRE usare `docker compose` (senza trattino)**: la sintassi `docker-compose` è DEPRECATA e non deve essere utilizzata.
- **Sintassi corretta**:
  - ✅ `docker compose up -d`
  - ✅ `docker compose down`
  - ✅ `docker compose ps`
  - ✅ `docker compose logs`
  - ❌ `docker-compose up -d` (DEPRECATO)
  - ❌ `docker-compose down` (DEPRECATO)
  - ❌ `docker-compose ps` (DEPRECATO)
- **Controllo obbligatorio**: prima di ogni commit, verificare che tutti i file (script, documentazione, configurazioni) usino la sintassi corretta.
- **Aggiornamento retroattivo**: tutti i file esistenti che usano la sintassi deprecata devono essere aggiornati immediatamente.
- **Documentazione**: tutti i comandi Docker nella documentazione devono usare la sintassi corretta.
- **Script**: tutti gli script bash, shell e di automazione devono usare la sintassi corretta.

## 11. Componenti riutilizzabili

- **Priorità ai componenti riutilizzabili**: dove possibile, creare componenti che possono essere riutilizzati in diverse parti dell'applicazione.
- **Principi di design**:
  - **Composizione**: preferire componenti piccoli e specializzati che possono essere combinati
  - **Props configurabili**: rendere i componenti flessibili tramite props per adattarli a diversi contesti
  - **Separazione delle responsabilità**: ogni componente deve avere una responsabilità specifica e ben definita
  - **Principio DRY (Don't Repeat Yourself)**: evitare duplicazione di codice tra componenti simili
- **Vantaggi**:
  - Riduzione della duplicazione del codice
  - Facilità di manutenzione e aggiornamenti
  - Consistenza nell'interfaccia utente
  - Migliore testabilità dei componenti
  - Riduzione del tempo di sviluppo per nuove funzionalità
- **Componenti UI di base obbligatori**:
  - ✅ **Button**: con varianti (primary, secondary, danger, success, ghost, outline) e stati (loading, disabled)
  - ✅ **Input**: con supporto per label, error, helper, icone (left/right)
  - ✅ **Modal/Dialog**: componente modale riutilizzabile per form e contenuti
  - ✅ **Table/DataTable**: componente tabella con sorting, filtering, pagination
  - ✅ **Form**: sistema di form riutilizzabile con validazione
  - ✅ **LoadingSpinner**: indicatore di caricamento standardizzato
  - ✅ **ErrorMessage**: gestione errori uniforme
  - ✅ **EmptyState**: stati vuoti per liste e contenuti
- **Layout components**:
  - ✅ Header, sidebar, footer, navigation
  - ✅ AppLayout, ClientLayout, ProtectedRoute
- **Utility components**:
  - ✅ Loading states, error states, empty states
  - ✅ Confirmation dialogs, tooltips, dropdowns
- **Componenti da evitare**:
  - ❌ Componenti monolitici troppo specifici (es. FormClienteCompleto di 74KB)
  - ❌ Componenti che duplicano logica esistente
  - ❌ Componenti che non possono essere riutilizzati in altri contesti
- **Best practice per la creazione**:
  - **Refactoring graduale**: suddividere componenti grandi in componenti più piccoli
  - **Composizione vs ereditarietà**: preferire la composizione di componenti piccoli
  - **Props interface**: definire sempre interfacce TypeScript per le props
  - **Default props**: fornire valori di default sensati per le props opzionali
  - **ForwardRef**: utilizzare React.forwardRef per componenti che devono esporre ref
- **Documentazione dei componenti**:
  - Ogni componente riutilizzabile deve essere documentato con esempi di utilizzo
  - Includere tutte le props disponibili con tipi TypeScript
  - Fornire esempi di codice per i casi d'uso più comuni
  - Documentare eventuali limitazioni o requisiti specifici
- **Organizzazione dei file**:
  - **`/components/ui/`**: componenti UI di base riutilizzabili
  - **`/components/layout/`**: componenti di layout (header, sidebar, footer)
  - **`/components/forms/`**: componenti specifici per form riutilizzabili
  - **`/components/tables/`**: componenti per tabelle e data display
  - **`/components/modals/`**: componenti modali e dialog
- **Controllo qualità**:
  - Prima di ogni commit, verificare che non ci sia duplicazione di codice tra componenti
  - Assicurarsi che i componenti esistenti vengano riutilizzati invece di crearne di nuovi
  - Testare che i componenti funzionino correttamente in diversi contesti

## 12. Gestione warning e elementi deprecati/obsoleti

- **NON ignorare mai i warning del terminale**: ogni warning deve essere analizzato e risolto.
- **Attenzione agli elementi deprecati**: identificare e aggiornare immediatamente elementi deprecati o obsoleti.
- **Best practice per la gestione dei warning**:
  - **Analisi immediata**: quando appare un warning, fermarsi e analizzarlo
  - **Ricerca soluzioni**: cercare la causa del warning e le soluzioni disponibili
  - **Applicazione correzioni**: implementare le correzioni necessarie prima di procedere
  - **Test post-correzione**: verificare che la correzione non introduca nuovi problemi
  - **Documentazione**: documentare le correzioni applicate e le motivazioni
- **Esempi di warning da non ignorare**:
  - ✅ Warning di sintassi deprecata (es. `docker-compose` vs `docker compose`)
  - ✅ Warning di configurazione obsoleta (es. `version` in docker-compose.yml)
  - ✅ Warning di sicurezza (es. vulnerabilità note)
  - ✅ Warning di performance (es. buildx non installato)
- **Procedura standard per i warning**:
  1. **Identificare** il tipo di warning
  2. **Ricercare** la causa e le soluzioni
  3. **Applicare** la correzione più appropriata
  4. **Testare** che tutto funzioni correttamente
  5. **Documentare** la correzione applicata
- **Controllo obbligatorio**: prima di ogni commit, verificare che non ci siano warning attivi nel sistema.

## 13. Gestione documentazione e file .md

- **Limitare la generazione di file .md superflui**: prima di creare un nuovo file .md, verificare se esiste già documentazione sull'argomento.
- **Priorità alla documentazione esistente**: cercare di utilizzare e aggiornare i file .md già presenti piuttosto che crearne di nuovi.
- **Unificazione per logica e argomenti**: raggruppare informazioni correlate negli stessi file, evitando frammentazione.
- **Eliminazione risultati non critici**: i risultati di test e analisi possono essere eliminati se non critici per il funzionamento o la sicurezza.
- **Best practice per la documentazione**:
  - **Ricerca prima di creare**: controllare sempre se esiste già documentazione sull'argomento
  - **Aggiornamento vs creazione**: preferire l'aggiornamento di file esistenti
  - **Raggruppamento logico**: mantenere informazioni correlate nello stesso file
  - **Eliminazione selettiva**: rimuovere solo risultati non critici, mantenendo informazioni importanti
  - **Struttura pulita**: evitare proliferazione di file con contenuti simili
- **Criteri per eliminazione**:
  - ✅ Risultati di test temporanei non critici
  - ✅ Analisi preliminari superate da versioni definitive
  - ✅ Log di debug non essenziali
  - ❌ Informazioni di sicurezza critiche
  - ❌ Configurazioni operative importanti
  - ❌ Procedure di backup e ripristino
  - ❌ Documentazione di architettura e struttura

---

**Queste regole sono parte integrante del progetto e vanno rispettate per garantire qualità, sicurezza e continuità operativa.**